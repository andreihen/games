function initFlowPhase(config) { 
    const gridSizes = [5,5,6,6,7,7,8,8,8,8]; const numPairsOptions = [3,3,4,4,4,5,5,5,6,6];
    const gridSize = gridSizes[Math.min(config.level, gridSizes.length-1)]; const numPairs = numPairsOptions[Math.min(config.level, numPairsOptions.length-1)];
    const flowColors = ['#FF0000','#00FF00','#0000FF','#FFFF00','#FF00FF','#00FFFF','#FFA500','#800080'].slice(0,numPairs);
    let grid = Array(gridSize).fill(null).map(()=>Array(gridSize).fill({color:null,type:'empty',pairId:null}));
    let dots = []; let pairIdCounter = 0;
    for(let i=0;i<numPairs;i++){for(let j=0;j<2;j++){let r,c;do{r=Math.floor(Math.random()*gridSize);c=Math.floor(Math.random()*gridSize);}while(grid[r][c].type!=='empty');grid[r][c]={color:flowColors[i],type:'dot',pairId:pairIdCounter};dots.push({r,c,color:flowColors[i],pairId:pairIdCounter});}pairIdCounter++;}
    let currentDrawingPath = null; let paths = Array(numPairs).fill(null).map(()=>[]);
    ui.phaseDisplay.innerHTML = `<div class="p-1 md:p-2 rounded-lg shadow-md w-full max-w-md"><h2 class="phase-title text-lg md:text-xl font-semibold mb-2 text-center">Conecte os Pontos</h2><p class="text-xs md:text-sm text-gray-300 mb-3 text-center">Conecte os pares da mesma cor sem cruzar. Preencha todo o grid!</p><div id="flow-grid-container" class="flow-grid mx-auto" style="grid-template-columns:repeat(${gridSize},1fr);width:${gridSize*35}px;height:${gridSize*35}px;"></div><div class="text-center mt-3"><button id="flow-reset" class="button button-secondary px-4 py-1.5 text-sm">Reiniciar</button></div></div>`;
    const gridContainer = document.getElementById('flow-grid-container');
    let localMouseUpHandler = null; 
    function renderFlowGrid(){gridContainer.innerHTML='';for(let r=0;r<gridSize;r++){for(let c=0;c<gridSize;c++){const cellDiv=document.createElement('div');cellDiv.classList.add('flow-cell');const cellData=grid[r][c];if(cellData.type==='dot'){const dotDiv=document.createElement('div');dotDiv.classList.add('flow-dot');dotDiv.style.backgroundColor=cellData.color;cellDiv.appendChild(dotDiv);}else if(cellData.type==='path'){cellDiv.style.backgroundColor=cellData.color+'60';cellDiv.classList.add('flow-path');}cellDiv.dataset.r=r;cellDiv.dataset.c=c;gridContainer.appendChild(cellDiv);}}}
    function handleMouseDown(e){if(!gameActive) return; const cellDiv=e.target.closest('.flow-cell');if(!cellDiv)return;const r=parseInt(cellDiv.dataset.r);const c=parseInt(cellDiv.dataset.c);const cellData=grid[r][c];if(cellData.type==='dot'){const existingPath=paths[cellData.pairId];if(existingPath){existingPath.forEach(pCell=>{if(grid[pCell.r][pCell.c].type==='path'){grid[pCell.r][pCell.c]={color:null,type:'empty',pairId:null};}});paths[cellData.pairId]=[];}currentDrawingPath={color:cellData.color,pairId:cellData.pairId,cells:[{r,c}]};grid[r][c]={...cellData,type:'path'};renderFlowGrid();}}
    function handleMouseMove(e){if(!currentDrawingPath || !gameActive)return;const cellDiv=e.target.closest('.flow-cell');if(!cellDiv)return;const r=parseInt(cellDiv.dataset.r);const c=parseInt(cellDiv.dataset.c);const lastCell=currentDrawingPath.cells[currentDrawingPath.cells.length-1];if(Math.abs(r-lastCell.r)+Math.abs(c-lastCell.c)!==1)return;const cellData=grid[r][c];if(cellData.type==='empty'){grid[r][c]={color:currentDrawingPath.color,type:'path',pairId:currentDrawingPath.pairId};currentDrawingPath.cells.push({r,c});renderFlowGrid();}else if(cellData.type==='dot'&&cellData.pairId===currentDrawingPath.pairId&&currentDrawingPath.cells.length>1){grid[r][c]={...cellData,type:'path'};currentDrawingPath.cells.push({r,c});paths[currentDrawingPath.pairId]=[...currentDrawingPath.cells];currentDrawingPath=null;renderFlowGrid();checkFlowWin();}else if(cellData.type==='path'&&cellData.pairId===currentDrawingPath.pairId){const existingCellIndex=currentDrawingPath.cells.findIndex(p=>p.r===r&&p.c===c);if(existingCellIndex!==-1&&existingCellIndex<currentDrawingPath.cells.length-1){const cellsToClear=currentDrawingPath.cells.splice(existingCellIndex+1);cellsToClear.forEach(pCell=>{if(grid[pCell.r][pCell.c].type==='path'){grid[pCell.r][pCell.c]={color:null,type:'empty',pairId:null};}});renderFlowGrid();}}}
    localMouseUpHandler = () => { if(!gameActive) return; if(currentDrawingPath){const pathCellsToClear=currentDrawingPath.cells;pathCellsToClear.forEach(pCell=>{const cell=grid[pCell.r][pCell.c];const originalDot=dots.find(d=>d.r===pCell.r&&d.c===pCell.c&&d.pairId===currentDrawingPath.pairId);if(!originalDot){grid[pCell.r][pCell.c]={color:null,type:'empty',pairId:null};}else{grid[pCell.r][pCell.c]={color:originalDot.color,type:'dot',pairId:originalDot.pairId};}});currentDrawingPath=null;renderFlowGrid();}};
    function resetFlowPaths(){paths.forEach(pathList=>{if(pathList){pathList.forEach(pCell=>{const originalDot=dots.find(d=>d.r===pCell.r&&d.c===pCell.c);if(!originalDot){grid[pCell.r][pCell.c]={color:null,type:'empty',pairId:null};}else{grid[pCell.r][pCell.c]={color:originalDot.color,type:'dot',pairId:originalDot.pairId};}});}});paths=Array(numPairs).fill(null).map(()=>[]);currentDrawingPath=null;renderFlowGrid();}
    document.getElementById('flow-reset').addEventListener('click',resetFlowPaths);
    gridContainer.addEventListener('mousedown',handleMouseDown);gridContainer.addEventListener('mousemove',handleMouseMove);document.addEventListener('mouseup',localMouseUpHandler);
    function checkFlowWin(){let allCellsFilled=true;let allPairsConnected=true;for(let r=0;r<gridSize;r++){for(let c=0;c<gridSize;c++){if(grid[r][c].type==='empty'){allCellsFilled=false;break;}}if(!allCellsFilled)break;}for(let i=0;i<numPairs;i++){if(!paths[i]||paths[i].length===0){allPairsConnected=false;break;}const path=paths[i];const pairDots=dots.filter(d=>d.pairId===i);const startDotConnected=path.some(p=>p.r===pairDots[0].r&&p.c===pairDots[0].c);const endDotConnected=path.some(p=>p.r===pairDots[1].r&&p.c===pairDots[1].c);if(!startDotConnected||!endDotConnected){allPairsConnected=false;break;}}if(allCellsFilled&&allPairsConnected){document.removeEventListener('mouseup',localMouseUpHandler);phaseCompleted(true,{text:"Todos os pontos conectados!"});}}
    renderFlowGrid();
}